# -*- coding: utf-8 -*-
"""Copy of Untitled9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bBehtSeP07bUcK2A6WseIGOvGPeFjCng

All the Algorithms script is mentioned belowed

Automation Script for Random Forest to impromise the  CPU and netwokr traffic Decision Tree
"""

import numpy as np
import psutil
import time
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import accuracy_score

def log_event(message):
    with open("decision_tree_logs.txt", "a") as f:
        f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - {message}\n")

# Simulate traffic data
np.random.seed(42)
X = np.random.rand(3000, 5) * 100
y = np.array([1 if np.random.rand() > 0.6 else 0 for _ in range(3000)])

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
model = DecisionTreeClassifier()
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

accuracy = accuracy_score(y_test, y_pred)
log_event(f"Algorithm: Decision Tree\nAccuracy: {accuracy:.2f}")

ddos_count = sum(y_pred)
total_predictions = len(y_pred)
ddos_ratio = ddos_count / total_predictions
if ddos_ratio > 0.3:
    log_event(f"DDoS detected: {ddos_count} out of {total_predictions} predictions.")

while True:
    cpu_usage = psutil.cpu_percent(interval=5)
    if cpu_usage > 30:
        log_event(f"High CPU usage detected: {cpu_usage}%")
    time.sleep(1)

"""Automation Script for Random Forest to impromise the  CPU and netwokr traffic"""

import numpy as np
import psutil
import time
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score

def log_event(message):
    with open("random_forest_logs.txt", "a") as f:
        f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - {message}\n")

# Simulate traffic data
np.random.seed(42)
X = np.random.rand(3000, 5) * 100
y = np.array([1 if np.random.rand() > 0.6 else 0 for _ in range(3000)])

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
model = RandomForestClassifier(n_estimators=100, random_state=42)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

accuracy = accuracy_score(y_test, y_pred)
log_event(f"Algorithm: Random Forest\nAccuracy: {accuracy:.2f}")

ddos_count = sum(y_pred)
total_predictions = len(y_pred)
ddos_ratio = ddos_count / total_predictions
if ddos_ratio > 0.3:
    log_event(f"DDoS detected: {ddos_count} out of {total_predictions} predictions.")

while True:
    cpu_usage = psutil.cpu_percent(interval=5)
    if cpu_usage > 30:
        log_event(f"High CPU usage detected: {cpu_usage}%")
    time.sleep(1)

"""Automation Script for Sector Vector Machine  to impromise the  CPU and netwokr traffic"""

import numpy as np
import psutil
import time
from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.metrics import accuracy_score

def log_event(message):
    with open("svm_logs.txt", "a") as f:
        f.write(f"{time.strftime('%Y-%m-%d %H:%M:%S')} - {message}\n")

# Simulate traffic data
np.random.seed(42)
X = np.random.rand(3000, 5) * 100
y = np.array([1 if np.random.rand() > 0.6 else 0 for _ in range(3000)])

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
model = SVC(kernel='rbf', probability=True)
model.fit(X_train, y_train)
y_pred = model.predict(X_test)

accuracy = accuracy_score(y_test, y_pred)
log_event(f"Algorithm: SVM\nAccuracy: {accuracy:.2f}")

ddos_count = sum(y_pred)
total_predictions = len(y_pred)
ddos_ratio = ddos_count / total_predictions
if ddos_ratio > 0.3:
    log_event(f"DDoS detected: {ddos_count} out of {total_predictions} predictions.")

while True:
    cpu_usage = psutil.cpu_percent(interval=5)
    if cpu_usage > 30:
        log_event(f"High CPU usage detected: {cpu_usage}%")
    time.sleep(1)

"""Decision tree Pre-Attack ,During Attack and Post-Attack Phase for CPU"""

import pandas as pd
import matplotlib.pyplot as plt

# Updated data
data = {
    "Timestamp": [
        "03-12-2024 11:30", "03-12-2024 11:35", "03-12-2024 11:40", "03-12-2024 11:45",
        "03-12-2024 11:50", "03-12-2024 11:55", "03-12-2024 12:00", "03-12-2024 12:05",
        "03-12-2024 12:10", "03-12-2024 12:15", "03-12-2024 12:20", "03-12-2024 12:25",
        "03-12-2024 12:30"
    ],
    "CPU_Utilization": [
        1.831771693, 1.631771693, 1.531771693, 1.831771693, 1.871771693,
        2.401667167, 4.091658917, 2.276673639, 2.333325556, 2.30834064,
        2.339999917, 2.299999917, 2.308333
    ]
}

# Convert the data to a DataFrame
df = pd.DataFrame(data)

# Convert 'Timestamp' to datetime format
df['Timestamp'] = pd.to_datetime(df['Timestamp'], format='%d-%m-%Y %H:%M')

# Define the time ranges for the phases
pre_attack_start = pd.Timestamp("2024-12-03 11:30:00")
pre_attack_end = pd.Timestamp("2024-12-03 11:50:00")
during_attack_start = pd.Timestamp("2024-12-03 11:50:01")
during_attack_end = pd.Timestamp("2024-12-03 12:10:00")
post_attack_start = pd.Timestamp("2024-12-03 12:10:01")
post_attack_end = pd.Timestamp("2024-12-03 12:30:00")

# Categorize data into phases
pre_attack = df[(df['Timestamp'] >= pre_attack_start) & (df['Timestamp'] <= pre_attack_end)]
during_attack = df[(df['Timestamp'] >= during_attack_start) & (df['Timestamp'] <= during_attack_end)]
post_attack = df[(df['Timestamp'] >= post_attack_start) & (df['Timestamp'] <= post_attack_end)]

# Plotting function
def plot_phase(data, title, color):
    if data.empty:
        print(f"No data available for {title}.")
    else:
        plt.figure(figsize=(8, 5))
        plt.plot(data['Timestamp'], data['CPU_Utilization'], marker='o', color=color, label=title)
        plt.title(f"CPU Utilization - {title}", fontsize=14)
        plt.xlabel("Timestamp", fontsize=12)
        plt.ylabel("CPU Utilization (%)", fontsize=12)
        plt.grid(True, linestyle='--', alpha=0.6)
        plt.xticks(rotation=45)
        plt.legend()
        plt.tight_layout()
        plt.show()

# Plot graphs for each phase with updated titles for Decision Tree context
plot_phase(pre_attack, "Decision Tree Analysis: Pre-Attack Phase", "blue")
plot_phase(during_attack, "Decision Tree Analysis: During Attack Phase", "red")
plot_phase(post_attack, "Decision Tree Analysis: Post-Attack Phase", "green")

"""Random Forest  Pre-Attack ,During Attack and Post-Attack Phase for CPU"""

import pandas as pd
import matplotlib.pyplot as plt

# Updated data
data = {
    "Timestamp": [
        "03-12-2024 12:35", "03-12-2024 12:40", "03-12-2024 12:45","03-12-2024 12:50",
        "03-12-2024 12:55", "03-12-2024 13:00", "03-12-2024 13:05", "03-12-2024 13:10",
        "03-12-2024 13:15", "03-12-2024 13:20", "03-12-2024 13:25", "03-12-2024 13:30"
    ],
    "CPU_Utilization": [
        2.303333333, 2.313333501, 2.313333501, 2.298333222,
        2.486665445, 2.69, 2.928333333, 4.975, 2.398333333,
        2.443325056, 2.410000195, 2.376674889
    ]
}

# Convert the data to a DataFrame
df = pd.DataFrame(data)

# Convert 'Timestamp' to datetime format
df['Timestamp'] = pd.to_datetime(df['Timestamp'], format='%d-%m-%Y %H:%M')

# Define the time ranges for the phases
pre_attack_start = pd.Timestamp("2024-12-03 12:35:00")
pre_attack_end = pd.Timestamp("2024-12-03 12:50:00")
during_attack_start = pd.Timestamp("2024-12-03 12:55:00")
during_attack_end = pd.Timestamp("2024-12-03 13:10:00")
post_attack_start = pd.Timestamp("2024-12-03 13:15:00")
post_attack_end = pd.Timestamp("2024-12-03 13:30:00")

# Categorize data into phases
pre_attack = df[(df['Timestamp'] >= pre_attack_start) & (df['Timestamp'] <= pre_attack_end)]
during_attack = df[(df['Timestamp'] >= during_attack_start) & (df['Timestamp'] <= during_attack_end)]
post_attack = df[(df['Timestamp'] >= post_attack_start) & (df['Timestamp'] <= post_attack_end)]

# Plotting function
def plot_phase(data, title, color):
    if data.empty:
        print(f"No data available for {title}.")
    else:
        plt.figure(figsize=(8, 5))
        plt.plot(data['Timestamp'], data['CPU_Utilization'], marker='o', color=color, label=title)
        plt.title(f"CPU Utilization - {title}", fontsize=14)
        plt.xlabel("Timestamp", fontsize=12)
        plt.ylabel("CPU Utilization (%)", fontsize=12)
        plt.grid(True, linestyle='--', alpha=0.6)
        plt.xticks(rotation=45)
        plt.legend()
        plt.tight_layout()
        plt.show()

# Plot graphs for each phase with updated titles for Random Forest context
plot_phase(pre_attack, "Random Forest Analysis: Pre-Attack Phase", "blue")
plot_phase(during_attack, "Random Forest Analysis: During Attack Phase", "red")
plot_phase(post_attack, "Random Forest Analysis: Post-Attack Phase", "green")

"""Sector Vector Machine  Pre-Attack ,During Attack and Post-Attack Phase for CPU"""

import pandas as pd
import matplotlib.pyplot as plt

# Updated data
data = {
    "Timestamp": [
        "03-12-2024 13:35", "03-12-2024 13:40", "03-12-2024 13:45","03-12-2024 13:50",
        "03-12-2024 13:55", "03-12-2024 14:00", "03-12-2024 14:05", "03-12-2024 14:10",
        "03-12-2024 14:15"
    ],
    "CPU_Utilization": [
        2.376666528, 2.406666612, 2.42, 2.586666667,
        4.804995668, 2.456666667, 2.375889, 2.39922,  2.4177795,
    ]
}

# Convert the data to a DataFrame
df = pd.DataFrame(data)

# Convert 'Timestamp' to datetime format
df['Timestamp'] = pd.to_datetime(df['Timestamp'], format='%d-%m-%Y %H:%M')

# Define the time ranges for the phases
pre_attack_start = pd.Timestamp("2024-12-03 13:35:00")
pre_attack_end = pd.Timestamp("2024-12-03 13:45:00")
during_attack_start = pd.Timestamp("2024-12-03 13:50:00")
during_attack_end = pd.Timestamp("2024-12-03 14:00:00")
post_attack_start = pd.Timestamp("2024-12-03 14:05:00")
post_attack_end = pd.Timestamp("2024-12-03 14:15:00")

# Categorize data into phases
pre_attack = df[(df['Timestamp'] >= pre_attack_start) & (df['Timestamp'] <= pre_attack_end)]
during_attack = df[(df['Timestamp'] >= during_attack_start) & (df['Timestamp'] <= during_attack_end)]
post_attack = df[(df['Timestamp'] >= post_attack_start) & (df['Timestamp'] <= post_attack_end)]

# Plotting function
def plot_phase(data, title, color):
    if data.empty:
        print(f"No data available for {title}.")
    else:
        plt.figure(figsize=(8, 5))
        plt.plot(data['Timestamp'], data['CPU_Utilization'], marker='o', color=color, label=title)
        plt.title(f"CPU Utilization - {title}", fontsize=14)
        plt.xlabel("Timestamp", fontsize=12)
        plt.ylabel("CPU Utilization (%)", fontsize=12)
        plt.grid(True, linestyle='--', alpha=0.6)
        plt.xticks(rotation=45)
        plt.legend()
        plt.tight_layout()
        plt.show()

# Plot graphs for each phase with updated titles for Support Vector Machine Tree context
plot_phase(pre_attack, "Support Vector Machine Tree Analysis: Pre-Attack Phase", "blue")
plot_phase(during_attack, "Support Vector Machine Tree Analysis: During Attack Phase", "red")
plot_phase(post_attack, "Support Vector Machine Tree Analysis: Post-Attack Phase", "green")

"""Accuracy Efficiency and Precison for Decision Tree ,Random Forest and Sector Vector Machine"""

import matplotlib.pyplot as plt

# Assumed data for Accuracy, Efficiency, and Precision for each algorithm
metrics = ['Accuracy', 'Efficiency', 'Precision']

# Decision Tree metrics (in percentages)
decision_tree_metrics = [92, 85, 88]
random_forest_metrics = [94, 83, 90]
svm_metrics = [89, 81, 87]

# Create individual bar graphs for each algorithm
def plot_algorithm_metrics(algorithm_name, metrics, scores, color):
    plt.figure(figsize=(8, 5))
    bars = plt.bar(metrics, scores, color=color)
    plt.xlabel('Metrics', fontsize=12)
    plt.ylabel('Score (%)', fontsize=12)
    plt.title(f'Performance Metrics: {algorithm_name}', fontsize=14)
    plt.ylim(0, 100)  # Ensure y-axis is consistent across graphs
    plt.grid(axis='y', linestyle='--', alpha=0.7)

    # Add percentage labels on top of the bars
    for bar, score in zip(bars, scores):
        plt.text(bar.get_x() + bar.get_width() / 2, bar.get_height() + 1,
                 f'{score}%', ha='center', fontsize=10)

    plt.tight_layout()
    plt.show()

# Plot for Decision Tree
plot_algorithm_metrics("Decision Tree", metrics, decision_tree_metrics, 'blue')

# Plot for Random Forest
plot_algorithm_metrics("Random Forest", metrics, random_forest_metrics, 'green')

# Plot for SVC
plot_algorithm_metrics("SVC", metrics, svm_metrics, 'orange')

"""best algorithm to use"""

import matplotlib.pyplot as plt
import numpy as np

# Assumed data for Accuracy, Efficiency, and Precision for each algorithm (in percentage)
metrics = ['Accuracy', 'Efficiency', 'Precision']

# Data for the algorithms (in percentage)
decision_tree_metrics = [92, 85, 88]
random_forest_metrics = [94, 83, 90]
svm_metrics = [89, 81, 87]

# Create the line graph
plt.figure(figsize=(10, 6))

# Plotting the line graphs for each algorithm
plt.plot(metrics, decision_tree_metrics, marker='o', label='Decision Tree', color='blue', linestyle='-', linewidth=2, markersize=8)
plt.plot(metrics, random_forest_metrics, marker='s', label='Random Forest', color='green', linestyle='-', linewidth=2, markersize=8)
plt.plot(metrics, svm_metrics, marker='^', label='SVM', color='orange', linestyle='-', linewidth=2, markersize=8)

# Labels and title
plt.xlabel('Metrics')
plt.ylabel('Score (%)')
plt.title('Performance of Models for CPU', fontsize=14)  # Updated title
plt.legend()

# Display grid and layout
plt.grid(True)
plt.tight_layout()
plt.show()